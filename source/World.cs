using System;
using System.Collections;
using System.Collections.Generic;

namespace Blockland {

  /// <summary>
  /// The world is a container for chunks. It spawns worker threads to manage the chunks.
  /// </summary>
  public class World {

    #region Constructor

    /// <summary>
    /// Create new world.
    /// </summary>
    /// <exception cref="Exception">When there already is a world</exception>
    public World() {
      if (mCurrent != null)
        throw new Exception("The world already exists");

      mCurrent = this;
    }

    #endregion Constructor

    #region Methods

    /// <summary>
    /// Start creating chunks and building the world.
    /// </summary>
    /// <param name="renderDistance">How many chunks to build around the player</param>
    /// <param name="height">World height in chunks</param>
    public void Create(int renderDistance, int height) {
      Console.WriteLine("Creating the world");

      mHeight = height;

      mAllocator = new ChunkAllocator(mChunksToGenerate, renderDistance, height);
      mGenerator = new ChunkGenerator(mChunksToGenerate, mChunksToBuild, height);
      mBuilder = new ChunkBuilder(mChunksToBuild, mChunksToBuildMain, mChunks);

      Program.Events.OnUpdate += Update;
    }

    /// <summary>
    /// Destroy the world.
    /// </summary>
    public void Destroy() {
      Program.Events.OnUpdate -= Update;

      mCurrent = null;
    }

    /// <summary>
    /// Update the world. The world will process chunks that have to be processed in the main thread.
    /// </summary>
    /// <param name="deltaTime">Not used</param>
    public void Update(float deltaTime) {
      while (mChunksToBuildMain.Count > 0) {

        ChunkBuilder.BuiltChunk builtChunk;
        lock (mChunksToBuildMain) {
          builtChunk = (ChunkBuilder.BuiltChunk)mChunksToBuildMain.Dequeue();
        }

        ProcessChunk(builtChunk);

        lock (mChunks) {
          mChunks.Add(builtChunk.Chunk.Position, builtChunk.Chunk);
        }

        GameObject gameObject = new GameObject();
        gameObject.AddComponent(new Transform(builtChunk.Chunk.Position.X * Chunk.Size * Block.Size, builtChunk.Chunk.Position.Y * Chunk.Size * Block.Size, builtChunk.Chunk.Position.Z * Chunk.Size * Block.Size));
        gameObject.AddComponent(builtChunk.Chunk);

        State.Current.AddGameObject(gameObject);
      }
    }

    /// <summary>
    /// Copy data generated by ChunkBuilder to chunk's buffer object.
    /// </summary>
    /// <param name="builtChunk">Chunk with vertex and element arrays</param>
    private void ProcessChunk(ChunkBuilder.BuiltChunk builtChunk) {
      Chunk chunk = builtChunk.Chunk;

      Console.WriteLine("Main thread processing chunk [{0}, {1}, {2}]", chunk.Position.X, chunk.Position.Y, chunk.Position.Z);

      chunk.ArrayObject.Create();
      chunk.ArrayObject.Bind();

      chunk.Vertices.Create();
      chunk.Vertices.CopyData(builtChunk.Vertices, true);
      chunk.Elements.Create();
      chunk.Elements.CopyData(builtChunk.Elements, true);

      ShaderProgram.Current.Attribute("inPosition", 3, 9, 0);
      ShaderProgram.Current.Attribute("inNormal", 3, 9, 3);
      ShaderProgram.Current.Attribute("inTexCoord", 3, 9, 6);
    }

    #endregion Methods

    #region Properties

    /// <summary>
    /// Get the current world instance.
    /// </summary>
    public static World Current {
      get {
        return mCurrent;
      }
    }

    /// <summary>
    /// Get world height.
    /// </summary>
    public int Height {
      get {
        return mHeight;
      }
    }

    /// <summary>
    /// Get chunks to build.
    /// </summary>
    public Queue ChunksToBuild {
      get {
        return mChunksToBuild;
      }
    }

    /// <summary>
    /// Get chunks to generate.
    /// </summary>
    public Queue ChunksToGenerate {
      get {
        return mChunksToGenerate;
      }
    }

    #endregion Properties

    #region Fields

    /// <summary>
    /// Static instance.
    /// </summary>
    private static World mCurrent;

    /// <summary>
    /// Chunk allocator thread.
    /// </summary>
    private ChunkAllocator mAllocator;

    /// <summary>
    /// Chunk builder thread.
    /// </summary>
    private ChunkBuilder mBuilder;

    /// <summary>
    /// Chunk generator thread.
    /// </summary>
    private ChunkGenerator mGenerator;

    /// <summary>
    /// World height in chunks.
    /// </summary>
    private int mHeight = 0;

    /// <summary>
    /// Dictionary of loaded and ready chunks.
    /// </summary>
    private Dictionary<Vector3i, Chunk> mChunks = new Dictionary<Vector3i, Chunk>();

    /// <summary>
    /// Queue of chunks waiting to be built.
    /// </summary>
    private Queue mChunksToBuild = new Queue();

    /// <summary>
    /// Chunks that need to be processed in the main thread.
    /// </summary>
    private Queue mChunksToBuildMain = new Queue();

    /// <summary>
    /// Queue of chunks waiting to be generated.
    /// </summary>
    private Queue mChunksToGenerate = new Queue();

    #endregion Fields

  }

}