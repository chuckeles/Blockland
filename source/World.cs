using System;
using System.Collections;
using System.Collections.Generic;

namespace Blockland {

  /// <summary>
  /// The world is a container for chunks. It spawns worker threads to manage the chunks.
  /// </summary>
  public class World {

    #region Constructor

    /// <summary>
    /// Create new world.
    /// </summary>
    /// <exception cref="Exception">When there already is a world</exception>
    public World() {
      if (mCurrent != null)
        throw new Exception("The world already exists");

      mCurrent = this;
    }

    #endregion Constructor

    #region Methods

    /// <summary>
    /// Start creating chunks and building the world.
    /// </summary>
    /// <param name="renderDistance">How many chunks to build around the player</param>
    /// <param name="height">World height in chunks</param>
    public void Create(int renderDistance, int height) {
      Console.WriteLine("Creating the world");

      mHeight = height;

      mAllocator = new ChunkAllocator(mChunksToGenerate, renderDistance, height);
      mGenerator = new ChunkGenerator(mChunksToGenerate, mChunksToBuild, height);
      mBuilder = new ChunkBuilder(mChunksToBuild, mChunksToBuildMain, mChunks);

      Program.Events.OnUpdate += Update;
    }

    /// <summary>
    /// Destroy the world.
    /// </summary>
    public void Destroy() {
      Program.Events.OnUpdate -= Update;

      mCurrent = null;
    }

    /// <summary>
    /// Update the world. The world will process chunks that have to be processed in the main thread.
    /// </summary>
    /// <param name="deltaTime">Not used</param>
    public void Update(float deltaTime) {
      if (mChunksToBuildMain.Count <= 0)
        return;

      Chunk chunk;
      lock (mChunksToBuildMain) {
        chunk = mChunksToBuildMain.Dequeue() as Chunk;
      }

      ProcessChunk(chunk);

      lock (mChunks) {
        mChunks.Add(chunk.Position, chunk);
      }

      GameObject gameObject = new GameObject();
      gameObject.AddComponent(new Transform(chunk.Position.X * Chunk.Size, chunk.Position.Y * Chunk.Size, chunk.Position.Z * Chunk.Size));
      gameObject.AddComponent(chunk);

      State.Current.AddGameObject(gameObject);
    }

    /// <summary>
    /// Copy data generated by ChunkBuilder to chunk's buffer object.
    /// </summary>
    /// <param name="chunk"></param>
    private void ProcessChunk(Chunk chunk) {
      Console.WriteLine("Main thread processing chunk [{0}, {1}, {2}]", chunk.Position.X, chunk.Position.Y, chunk.Position.Z);
    }

    #endregion Methods

    #region Properties

    /// <summary>
    /// Get the current world instance.
    /// </summary>
    public static World Current {
      get {
        return mCurrent;
      }
    }

    /// <summary>
    /// Get world height.
    /// </summary>
    public int Height {
      get {
        return mHeight;
      }
    }

    /// <summary>
    /// Get chunks to build.
    /// </summary>
    public Queue ChunksToBuild {
      get {
        return mChunksToBuild;
      }
    }

    /// <summary>
    /// Get chunks to generate.
    /// </summary>
    public Queue ChunksToGenerate {
      get {
        return mChunksToGenerate;
      }
    }

    #endregion Properties

    #region Fields

    /// <summary>
    /// Static instance.
    /// </summary>
    private static World mCurrent;

    /// <summary>
    /// Chunk allocator thread.
    /// </summary>
    private ChunkAllocator mAllocator;

    /// <summary>
    /// Chunk builder thread.
    /// </summary>
    private ChunkBuilder mBuilder;

    /// <summary>
    /// Chunk generator thread.
    /// </summary>
    private ChunkGenerator mGenerator;

    /// <summary>
    /// World height in chunks.
    /// </summary>
    private int mHeight = 0;

    /// <summary>
    /// Dictionary of loaded and ready chunks.
    /// </summary>
    private Dictionary<Vector3i, Chunk> mChunks = new Dictionary<Vector3i, Chunk>();

    /// <summary>
    /// Queue of chunks waiting to be built.
    /// </summary>
    private Queue mChunksToBuild = new Queue();

    /// <summary>
    /// Chunks that need to be processed in the main thread.
    /// </summary>
    private Queue mChunksToBuildMain = new Queue();

    /// <summary>
    /// Queue of chunks waiting to be generated.
    /// </summary>
    private Queue mChunksToGenerate = new Queue();

    #endregion Fields

  }

}